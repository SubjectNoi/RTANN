#pragma once
#ifndef JUNO_CORE_H_
#define JUNO_CORE_H_

#include "utils.hpp"
#include "juno_rt.hpp"
#include "juno_query.hpp"
namespace juno {

template <typename T>
class juno_core {
private:
    std::string dataset_dir;

    // dataset property
    int         N;
    int         M;
    int         D;
    int         Q;
    int         PQ_entry;
    METRIC      metric;

    // juno impl property
    bool        use_pq;
    int         coarse_grained_cluster_num;
    RT_MODE     rt_mode;   

    // data
    T**         search_points;
    T*          search_points_flatten;
    T**         cluster_centroids;
    T*          cluster_centroids_flatten;
    std::vector<std::pair<int, std::vector <T>>> cluster_centroids_vec;
    T*          square_C;               // [ Offline]: coarse_grained_cluster_num * D
    T*          square_Q;               // [  Online]: query_batch_size * D
    int*        search_points_labels;
    int**       ground_truth;
    int*        ground_truth_flatten;
    int*        cluster_size;
    T           radius;
    T**         stat;
    T****       codebook_entry;         // [C][D/M][E][M]
    int***      codebook_labels;        // [C][D/M][]
    std::vector<int>*** inversed_codebook_map; // [C][D/M][32][]
    // std::vector<int>*** inversed_codebook_map_localid;
    uint8_t*    hit_res;
    int*        sub_cluster_size;       // [C * D/M * 32]
    
    std::map<int, std::vector<int>> points_cluster_mapping;

    // BVH dict
    std::map<int, juno_rt<T>*> bvh_dict;
    CUstream    stream;
    float factors[64] = {226.91, 226.292, 234.105, 245.577, 279.63, 236.516, 231.948, 269.431, 274.614, 244.002, 235.553, 258.38, 243.939, 237.857, 229.811, 229.819, 244.322, 226.982, 252.21, 246.903, 265.966, 238.008, 231.935, 249.658, 278.304, 241.357, 236.966, 259.187, 245.247, 245.449, 244.663, 229.863, 238.673, 245.904, 235.468, 238.296, 266.595, 246.564, 229.863, 245.392, 275.224, 245.247, 239.019, 254.136, 239.708, 236.212, 248.244, 244.125, 237.346, 247.491, 225.754, 225.657, 276.957, 235.85, 229.142, 265.548, 285.272, 237.186, 252.723, 263.139, 240.983, 220.048, 237.626, 236.326};
    // int nl32[] = {2, 6, 7, 8, 10, 25, 28, 30, 32, 33, 34, 42, 49, 51, 52, 54, 56, 63, 68, 69, 71, 74, 78, 81, 88, 89, 96, 98, 102, 109, 111, 114, 115, 118, 124, 131, 132, 135, 138, 139, 142, 148, 150, 154, 155, 158, 159, 160, 165, 166, 169, 170, 174, 176, 181, 184, 186, 190, 193, 196, 197, 202, 203, 207, 209, 211, 214, 218, 224, 225, 226, 227, 230, 243, 247, 249, 252, 253, 254, 256, 257, 259, 264, 266, 272, 284, 291, 294, 307, 311, 320, 321, 323, 324, 333, 348, 357, 359, 378, 386, 387, 389, 393, 396, 397, 400, 407, 413, 418, 420, 421, 423, 426, 427, 432, 434, 443, 444, 446, 452, 454, 456, 457, 459, 461, 469, 470, 472, 474, 475, 476, 480, 482, 483, 484, 485, 486, 490, 493, 495, 497, 498, 501, 503, 504, 507, 509, 515, 524, 526, 527, 536, 537, 539, 552, 558, 559, 561, 568, 576, 578, 580, 583, 586, 588, 589, 592, 597, 599, 600, 602, 608, 614, 617, 627, 629, 640, 641, 642, 650, 651, 653, 654, 657, 658, 660, 661, 666, 667, 679, 681, 692, 698, 708, 709, 713, 724, 727, 739, 741, 744, 747, 760, 764, 769, 779, 786, 799, 800, 803, 808, 812, 813, 821, 827, 832, 837, 841, 842, 848, 859, 861, 868, 870, 874, 881, 883, 896, 898, 899, 900, 901, 902, 905, 913, 914, 916, 919, 930, 932, 947, 948, 959, 962, 966, 972, 981, 985, 991, 995, 1000, 1003, 1007, 1011, 1012, 1014, 1015, 1021, 1022, 1029, 1034, 1040, 1042, 1044, 1045, 1047, 1050, 1056, 1059, 1061, 1063, 1066, 1067, 1068, 1073, 1078, 1085, 1088, 1091, 1093, 1103, 1105, 1107, 1111, 1114, 1115, 1117, 1119, 1121, 1124, 1131, 1133, 1142, 1146, 1154, 1162, 1163, 1165, 1168, 1169, 1172, 1174, 1184, 1186, 1188, 1196, 1212, 1250, 1260, 1267, 1272, 1274, 1276, 1292, 1310, 1311, 1313, 1328, 1340, 1350, 1362, 1381, 1388, 1395, 1403, 1408, 1412, 1414, 1420, 1421, 1422, 1431, 1432, 1435, 1437, 1440, 1442, 1444, 1449, 1452, 1458, 1462, 1465, 1468, 1469, 1470, 1471, 1474, 1478, 1484, 1485, 1488, 1490, 1491, 1507, 1510, 1514, 1520, 1521, 1527, 1530, 1533, 1535, 1537, 1538, 1539, 1543, 1544, 1548, 1552, 1555, 1556, 1557, 1558, 1566, 1568, 1569, 1571, 1574, 1575, 1579, 1594, 1595, 1597, 1598, 1600, 1602, 1605, 1607, 1610, 1611, 1614, 1616, 1617, 1619, 1620, 1621, 1622, 1623, 1624, 1626, 1627, 1631, 1632, 1633, 1634, 1638, 1639, 1646, 1653, 1654, 1655, 1660, 1663, 1664, 1666, 1668, 1669, 1675, 1676, 1677, 1683, 1688, 1690, 1692, 1693, 1694, 1696, 1697, 1701, 1702, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1719, 1722, 1723, 1724, 1725, 1726, 1729, 1733, 1738, 1740, 1742, 1745, 1746, 1748, 1751, 1752, 1754, 1756, 1757, 1758, 1761, 1763, 1764, 1767, 1768, 1770, 1772, 1773, 1776, 1777, 1778, 1779, 1781, 1782, 1783, 1785, 1787, 1791, 1792, 1794, 1795, 1796, 1797, 1798, 1799, 1805, 1811, 1856, 1873, 1953, 1966, 1970, 1978, 2010, 2015, 2020, 2027, 2031, 2032, 2033, 2049, 2064, 2075, 2078, 2079, 2080, 2083, 2097, 2101, 2106, 2110, 2121, 2134, 2135, 2148, 2150, 2161, 2190, 2202, 2206, 2210, 2211, 2215, 2219, 2220, 2241, 2243, 2248, 2263, 2267, 2269, 2275, 2277, 2280, 2283, 2287, 2291, 2304, 2307, 2308, 2314, 2318, 2320, 2324, 2338, 2342, 2343, 2348, 2352, 2355, 2356, 2357, 2358, 2361, 2367, 2370, 2371, 2381, 2387, 2389, 2390, 2392, 2395, 2396, 2397, 2399, 2400, 2403, 2410, 2413, 2419, 2420, 2421, 2422, 2423, 2425, 2430, 2431, 2432, 2448, 2449, 2451, 2458, 2460, 2461, 2462, 2464, 2465, 2470, 2471, 2475, 2480, 2485, 2487, 2488, 2489, 2493, 2494, 2495, 2497, 2498, 2500, 2504, 2515, 2516, 2517, 2525, 2526, 2527, 2528, 2530, 2531, 2534, 2537, 2539, 2544, 2546, 2547, 2548, 2549, 2553, 2555, 2558, 2561, 2562, 2564, 2567, 2569, 2573, 2574, 2579, 2584, 2586, 2588, 2596, 2601, 2608, 2609, 2611, 2612, 2616, 2617, 2618, 2619, 2620, 2621, 2624, 2626, 2629, 2630, 2632, 2634, 2635, 2636, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2649, 2650, 2651, 2652, 2654, 2655, 2656, 2658, 2661, 2662, 2664, 2668, 2669, 2673, 2674, 2675, 2676, 2677, 2678, 2681, 2682, 2683, 2684, 2686, 2687, 2688, 2689, 2693, 2694, 2696, 2697, 2699, 2700, 2701, 2703, 2704, 2705, 2706, 2707, 2710, 2711, 2713, 2714, 2715, 2717, 2719, 2721, 2722, 2723, 2725, 2727, 2728, 2729, 2730, 2731, 2733, 2734, 2735, 2736, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2747, 2748, 2750, 2751, 2753, 2754, 2756, 2757, 2758, 2759, 2764, 2769, 2771, 2772, 2773, 2774, 2776, 2777, 2779, 2780, 2782, 2784, 2785, 2787, 2788, 2789, 2790, 2795, 2798, 2807, 2810, 2815, 2820, 2824, 2825, 2830, 2831, 2835, 2839, 2842, 2861, 2870, 2873, 2882, 2883, 2884, 2887, 2895, 2901, 2902, 2912, 2915, 2920, 2923, 2926, 2928, 2929, 2941, 2944, 2949, 2960, 2966, 2969, 2970, 2985, 2988, 2994, 2996, 2997, 2998, 3026, 3037, 3039, 3067, 3074, 3079, 3083, 3091, 3100, 3103, 3106, 3107, 3108, 3115, 3126, 3136, 3163, 3165, 3171, 3172, 3176, 3177, 3188, 3192, 3193, 3195, 3197, 3200, 3202, 3206, 3210, 3211, 3217, 3218, 3221, 3225, 3228, 3230, 3234, 3235, 3239, 3244, 3246, 3247, 3249, 3250, 3251, 3252, 3254, 3255, 3256, 3257, 3262, 3265, 3266, 3267, 3271, 3273, 3274, 3279, 3281, 3285, 3286, 3288, 3292, 3293, 3295, 3296, 3297, 3298, 3301, 3309, 3312, 3315, 3323, 3324, 3325, 3327, 3332, 3338, 3340, 3342, 3345, 3348, 3351, 3356, 3358, 3364, 3365, 3372, 3374, 3376, 3379, 3380, 3383, 3387, 3392, 3393, 3397, 3403, 3418, 3435, 3436, 3442, 3446, 3449, 3458, 3464, 3469, 3474, 3477, 3487, 3488, 3515, 3533, 3541, 3561, 3562, 3569, 3572, 3581, 3584, 3585, 3591, 3595, 3596, 3600, 3601, 3603, 3608, 3612, 3613, 3614, 3615, 3619, 3620, 3621, 3622, 3626, 3627, 3629, 3630, 3633, 3636, 3637, 3638, 3640, 3641, 3642, 3643, 3644, 3647, 3650, 3652, 3658, 3662, 3663, 3667, 3669, 3671, 3674, 3679, 3680, 3683, 3684, 3685, 3688, 3689, 3693, 3695, 3696, 3697, 3698, 3702, 3703, 3704, 3706, 3707, 3711, 3714, 3717, 3718, 3721, 3724, 3725, 3729, 3731, 3732, 3736, 3737, 3740, 3743, 3745, 3750, 3752, 3753, 3754, 3755, 3757, 3758, 3759, 3763, 3764, 3765, 3766, 3767, 3770, 3777, 3779, 3782, 3783, 3790, 3791, 3794, 3796, 3800, 3802, 3806, 3813, 3818, 3822, 3823, 3833, 3852, 3854, 3858, 3861, 3862, 3876, 3877, 3881, 3887, 3896, 3899, 3904, 3906, 3911, 3918, 3921, 3927, 3931, 3934, 3937, 3942, 3945, 3948, 3949, 3957, 3963, 3970, 3971, 3972, 3976, 3977, 3983, 3985, 3988, 3991, 3999, 4010, 4012, 4040, 4054, 4060, 4061, 4072, 4075, 4090, 4092, 4099, 4112, 4123, 4134, 4162, 4168, 4182, 4191, 4206, 4212, 4214, 4221, 4226, 4235, 4240, 4245, 4263, 4273, 4275, 4278, 4280, 4288, 4291, 4293, 4298, 4307, 4308, 4309, 4317, 4319, 4330, 4332, 4335, 4336, 4350, 4352, 4354, 4357, 4360, 4361, 4362, 4364, 4372, 4376, 4377, 4379, 4381, 4384, 4395, 4397, 4398, 4401, 4403, 4405, 4406, 4407, 4408, 4409, 4417, 4422, 4426, 4427, 4431, 4433, 4435, 4442, 4443, 4446, 4447, 4450, 4451, 4456, 4457, 4460, 4462, 4463, 4464, 4466, 4471, 4472, 4473, 4476, 4477, 4478, 4480, 4482, 4484, 4485, 4489, 4493, 4494, 4496, 4498, 4503, 4511, 4512, 4518, 4521, 4524, 4528, 4529, 4532, 4533, 4535, 4540, 4543, 4546, 4547, 4548, 4549, 4550, 4552, 4553, 4554, 4556, 4557, 4558, 4560, 4562, 4564, 4566, 4569, 4570, 4571, 4573, 4574, 4575, 4579, 4588, 4589, 4590, 4594, 4609, 4614, 4622, 4628, 4630, 4637, 4640, 4649, 4652, 4659, 4660, 4663, 4664, 4677, 4680, 4701, 4705, 4706, 4708, 4712, 4719, 4728, 4730, 4731, 4732, 4749, 4767, 4775, 4785, 4786, 4796, 4798, 4800, 4802, 4805, 4808, 4809, 4811, 4812, 4815, 4818, 4820, 4824, 4825, 4826, 4827, 4828, 4830, 4831, 4832, 4834, 4836, 4837, 4838, 4839, 4840, 4844, 4845, 4847, 4848, 4849, 4851, 4856, 4857, 4859, 4860, 4866, 4867, 4868, 4869, 4874, 4875, 4877, 4878, 4880, 4882, 4885, 4888, 4890, 4891, 4893, 4899, 4900, 4901, 4902, 4903, 4906, 4910, 4912, 4914, 4917, 4920, 4922, 4924, 4928, 4929, 4930, 4933, 4935, 4936, 4940, 4941, 4942, 4943, 4945, 4946, 4949, 4950, 4951, 4956, 4958, 4964, 4966, 4967, 4968, 4970, 4971, 4972, 4976, 4977, 4979, 4983, 4986, 4987, 4988, 4991, 4992, 4993, 4995, 4996, 4997, 5013, 5021, 5027, 5038, 5048, 5091, 5099, 5101, 5109, 5112, 5127, 5140, 5143, 5148, 5163, 5188, 5191, 5197, 5202, 5203, 5213, 5218, 5219, 5227, 5231, 5237, 5245, 5249, 5251, 5256, 5257, 5262, 5264, 5266, 5271, 5273, 5276, 5279, 5280, 5281, 5283, 5288, 5290, 5292, 5296, 5297, 5299, 5303, 5304, 5305, 5308, 5312, 5314, 5315, 5319, 5320, 5322, 5323, 5325, 5326, 5327, 5336, 5338, 5347, 5348, 5350, 5351, 5353, 5355, 5358, 5365, 5366, 5370, 5371, 5372, 5380, 5382, 5385, 5390, 5392, 5394, 5400, 5401, 5406, 5408, 5410, 5412, 5413, 5415, 5419, 5420, 5421, 5423, 5426, 5430, 5431, 5432, 5436, 5437, 5438, 5441, 5448, 5455, 5457, 5458, 5460, 5461, 5462, 5465, 5471, 5473, 5474, 5477, 5479, 5480, 5481, 5484, 5491, 5493, 5494, 5497, 5504, 5506, 5507, 5509, 5510, 5511, 5513, 5514, 5515, 5518, 5519, 5525, 5527, 5528, 5529, 5530, 5532, 5537, 5540, 5543, 5544, 5545, 5546, 5549, 5551, 5552, 5554, 5555, 5556, 5557, 5559, 5562, 5564, 5568, 5569, 5570, 5571, 5573, 5575, 5577, 5578, 5579, 5581, 5593, 5596, 5597, 5600, 5601, 5607, 5618, 5627, 5630, 5631, 5639, 5648, 5657, 5659, 5662, 5670, 5671, 5674, 5683, 5684, 5686, 5702, 5704, 5706, 5707, 5717, 5723, 5726, 5727, 5735, 5738, 5741, 5742, 5744, 5753, 5757, 5761, 5769, 5771, 5773, 5776, 5778, 5783, 5787, 5790, 5793, 5794, 5802, 5805, 5813, 5820, 5822, 5833, 5846, 5847, 5848, 5865, 5872, 5873, 5880, 5883, 5884, 5890, 5892, 5897, 5905, 5906, 5911, 5913, 5916, 5917, 5928, 5931, 5936, 5938, 5958, 5964, 5967, 5968, 5974, 5975, 5978, 5979, 5982, 5988, 6003, 6004, 6008, 6011, 6017, 6018, 6026, 6029, 6033, 6049, 6050, 6053, 6055, 6057, 6064, 6066, 6070, 6074, 6077, 6078, 6081, 6084, 6089, 6095, 6096, 6097, 6098, 6102, 6104, 6105, 6120, 6121, 6125, 6137, 6138, 6143, 6146, 6150, 6155, 6163, 6172, 6174, 6175, 6181, 6187, 6188, 6195, 6198, 6199, 6207, 6209, 6216, 6219, 6220, 6223, 6224, 6225, 6227, 6228, 6233, 6239, 6242, 6245, 6248, 6249, 6254, 6256, 6268, 6273, 6276, 6277, 6279, 6280, 6283, 6290, 6291, 6295, 6298, 6302, 6304, 6305, 6306, 6307, 6310, 6314, 6317, 6327, 6330, 6331, 6337, 6339, 6341, 6346, 6351, 6357, 6358, 6362, 6369, 6370, 6373, 6376, 6384, 6385, 6386, 6388, 6393, 6397, 6398, 6401, 6405, 6413, 6415, 6416, 6417, 6423, 6429, 6433, 6437, 6438, 6445, 6462, 6466, 6467, 6470, 6483, 6485, 6491, 6493, 6512, 6517, 6520, 6523, 6525, 6533, 6544, 6545, 6553, 6557, 6565, 6570, 6590, 6591, 6593, 6594, 6595, 6598, 6602, 6603, 6605, 6606, 6607, 6613, 6617, 6618, 6626, 6638, 6639, 6641, 6647, 6653, 6654, 6655, 6659, 6664, 6669, 6671, 6674, 6676, 6685, 6689, 6696, 6706, 6714, 6717, 6726, 6737, 6738, 6739, 6744, 6770, 6776, 6780, 6794, 6796, 6797, 6799, 6805, 6810, 6812, 6822, 6831, 6832, 6833, 6834, 6835, 6841, 6859, 6861, 6863, 6865, 6870, 6871, 6876, 6881, 6885, 6887, 6897, 6900, 6901, 6902, 6903, 6905, 6906, 6912, 6913, 6914, 6915, 6917, 6918, 6921, 6924, 6929, 6930, 6932, 6933, 6934, 6944, 6945, 6946, 6950, 6951, 6952, 6953, 6956, 6957, 6958, 6959, 6962, 6968, 6974, 6977, 6979, 6980, 6981, 6982, 6985, 6987, 6988, 6989, 6993, 6995, 6999, 7004, 7005, 7013, 7024, 7027, 7031, 7032, 7034, 7038, 7039, 7041, 7044, 7049, 7050, 7054, 7055, 7057, 7060, 7062, 7070, 7071, 7073, 7076, 7083, 7089, 7098, 7100, 7107, 7113, 7123, 7127, 7129, 7136, 7137, 7138, 7155, 7158, 7159, 7161, 7162, 7165, 7167, 7171, 7176, 7178, 7181, 7187, 7190, 7191, 7192, 7194, 7199, 7204, 7208, 7209, 7211, 7215, 7217, 7218, 7219, 7220, 7221, 7223, 7224, 7226, 7229, 7232, 7236, 7237, 7238, 7247, 7250, 7252, 7253, 7258, 7263, 7269, 7270, 7275, 7276, 7280, 7285, 7286, 7300, 7301, 7304, 7306, 7309, 7311, 7315, 7317, 7327, 7337, 7344, 7351, 7353, 7365, 7366, 7371, 7372, 7376, 7381, 7384, 7389, 7394, 7399, 7405, 7408, 7409, 7411, 7414, 7415, 7429, 7436, 7441, 7451, 7459, 7460, 7477, 7480, 7490, 7493, 7504, 7512, 7518, 7522, 7526, 7531, 7532, 7534, 7535, 7555, 7576, 7581, 7586, 7593, 7594, 7600, 7604, 7605, 7606, 7607, 7608, 7618, 7619, 7621, 7623, 7624, 7628, 7629, 7630, 7631, 7635, 7639, 7648, 7655, 7656, 7659, 7661, 7668, 7671, 7672, 7673, 7678, 7680, 7682, 7683, 7685, 7693, 7698, 7705, 7707, 7710, 7716, 7717, 7724, 7734, 7737, 7738, 7750, 7760, 7764, 7766, 7769, 7771, 7776, 7783, 7784, 7786, 7788, 7791, 7792, 7793, 7794, 7795, 7799, 7802, 7806, 7810, 7811, 7815, 7817, 7822, 7826, 7828, 7830, 7833, 7835, 7837, 7839, 7842, 7850, 7852, 7860, 7861, 7867, 7878, 7882, 7885, 7886, 7889, 7893, 7894, 7896, 7899, 7901, 7904, 7915, 7919, 7922, 7923, 7928, 7931, 7936, 7937, 7942, 7944, 7953, 7956, 7957, 7960, 7964, 7970, 7994, 7998, 7999, 8002, 8003, 8007, 8008, 8009, 8014, 8015, 8016, 8018, 8020, 8021, 8022, 8023, 8024, 8027, 8028, 8032, 8035, 8043, 8044, 8055, 8057, 8058, 8059, 8062, 8064, 8067, 8071, 8072, 8074, 8075, 8076, 8077, 8079, 8080, 8081, 8082, 8084, 8090, 8091, 8094, 8095, 8097, 8098, 8101, 8106, 8107, 8109, 8111, 8113, 8116, 8118, 8119, 8122, 8123, 8124, 8128, 8129, 8131, 8132, 8137, 8139, 8140, 8141, 8142, 8144, 8146, 8149, 8151, 8152, 8153, 8154, 8155, 8156, 8158, 8159, 8160, 8161, 8163, 8165, 8166, 8167, 8168, 8170, 8173, 8174, 8177, 8181, 8183, 8184, 8185, 8186, 8191, 8192, 8194, 8195, 8196, 8199, 8200, 8201, 8203, 8204, 8205, 8206, 8207, 8208, 8209, 8212, 8213, 8214, 8215, 8216, 8217, 8220, 8225, 8226, 8228, 8231, 8232, 8235, 8236, 8247, 8250, 8252, 8253, 8255, 8256, 8257, 8259, 8262, 8264, 8266, 8269, 8273, 8274, 8275, 8276, 8280, 8284, 8285, 8287, 8289, 8290, 8294, 8295, 8298, 8300, 8301, 8302, 8306, 8308, 8313, 8314, 8316, 8321, 8322, 8323, 8324, 8326, 8328, 8331, 8332, 8335, 8336, 8340, 8343, 8346, 8347, 8348, 8352, 8353, 8359, 8361, 8365, 8367, 8368, 8370, 8374, 8375, 8380, 8393, 8394, 8395, 8397, 8399, 8409, 8413, 8420, 8424, 8438, 8439, 8451, 8454, 8458, 8474, 8477, 8480, 8486, 8492, 8498, 8501, 8505, 8507, 8510, 8522, 8529, 8530, 8532, 8533, 8537, 8542, 8544, 8552, 8555, 8562, 8565, 8567, 8569, 8571, 8572, 8579, 8583, 8586, 8592, 8595, 8597, 8600, 8605, 8608, 8609, 8613, 8614, 8617, 8618, 8619, 8620, 8621, 8623, 8624, 8625, 8627, 8629, 8632, 8633, 8634, 8635, 8637, 8638, 8639, 8640, 8642, 8643, 8648, 8649, 8651, 8657, 8658, 8659, 8661, 8664, 8665, 8671, 8677, 8680, 8681, 8682, 8685, 8686, 8693, 8694, 8697, 8703, 8704, 8706, 8708, 8710, 8714, 8719, 8721, 8722, 8723, 8730, 8732, 8735, 8736, 8737, 8738, 8739, 8740, 8741, 8743, 8744, 8746, 8748, 8749, 8754, 8755, 8757, 8758, 8759, 8760, 8761, 8763, 8764, 8765, 8767, 8768, 8770, 8771, 8773, 8777, 8780, 8786, 8787, 8789, 8790, 8791, 8792, 8796, 8797, 8798, 8823, 8828, 8829, 8831, 8843, 8845, 8850, 8864, 8866, 8876, 8924, 8930, 8937, 8952, 8959, 8970, 8981, 8992, 9001, 9003, 9005, 9006, 9008, 9010, 9016, 9018, 9023, 9040, 9041, 9047, 9048, 9049, 9052, 9055, 9062, 9067, 9074, 9079, 9080, 9089, 9093, 9095, 9100, 9108, 9114, 9123, 9127, 9132, 9133, 9135, 9136, 9138, 9141, 9150, 9154, 9157, 9158, 9159, 9160, 9161, 9165, 9169, 9173, 9174, 9176, 9184, 9192, 9203, 9206, 9208, 9209, 9210, 9211, 9212, 9217, 9234, 9236, 9240, 9241, 9242, 9246, 9254, 9255, 9258, 9265, 9268, 9270, 9273, 9274, 9277, 9278, 9280, 9282, 9283, 9285, 9286, 9289, 9290, 9291, 9293, 9296, 9297, 9300, 9301, 9302, 9305, 9307, 9311, 9323, 9324, 9325, 9326, 9328, 9335, 9339, 9344, 9349, 9355, 9359, 9360, 9363, 9364, 9367, 9369, 9371, 9373, 9374, 9376, 9378, 9379, 9383, 9384, 9386, 9388, 9389, 9391, 9392, 9395, 9396, 9397, 9400, 9410, 9411, 9412, 9414, 9416, 9417, 9428, 9461, 9462, 9463, 9478, 9487, 9489, 9506, 9512, 9513, 9519, 9522, 9524, 9531, 9553, 9554, 9572, 9586, 9593, 9597, 9607, 9623, 9628, 9630, 9635, 9640, 9641, 9651, 9666, 9671, 9672, 9678, 9686, 9687, 9695, 9697, 9699, 9702, 9704, 9732, 9735, 9736, 9740, 9741, 9755, 9760, 9769, 9772, 9774, 9784, 9787, 9788, 9795, 9798, 9805, 9806, 9809, 9812, 9815, 9820, 9825, 9829, 9832, 9835, 9838, 9840, 9845, 9846, 9850, 9854, 9858, 9859, 9861, 9862, 9864, 9865, 9867, 9870, 9871, 9875, 9878, 9883, 9886, 9887, 9889, 9891, 9893, 9894, 9899, 9900, 9908, 9910, 9912, 9913, 9914, 9917, 9921, 9926, 9928, 9932, 9937, 9941, 9942, 9944, 9948, 9950, 9951, 9955, 9956, 9963, 9966, 9968, 9969, 9976, 9978, 9982, 9984, 9985, 9986, 9987, 9991, 9992, 9993, 9994, 9995, 9999};
    // std::vector<int> nl16 = {2, 7, 8, 10, 28, 30, 32, 33, 51, 52, 63, 68, 71, 81, 88, 98, 102, 109, 124, 132, 148, 150, 155, 158, 165, 169, 181, 184, 190, 193, 197, 207, 211, 214, 218, 225, 226, 230, 249, 254, 264, 272, 284, 320, 321, 323, 324, 357, 359, 386, 413, 418, 423, 432, 434, 443, 444, 446, 452, 454, 457, 461, 469, 472, 475, 476, 480, 484, 485, 486, 490, 497, 501, 515, 524, 536, 537, 539, 552, 558, 576, 580, 592, 599, 600, 602, 614, 617, 627, 640, 642, 650, 651, 653, 657, 661, 666, 667, 679, 681, 708, 709, 713, 727, 741, 769, 779, 799, 800, 803, 812, 821, 837, 841, 861, 881, 898, 899, 900, 901, 902, 914, 916, 930, 947, 948, 966, 995, 1011, 1012, 1029, 1034, 1042, 1044, 1045, 1050, 1061, 1063, 1078, 1093, 1105, 1107, 1119, 1131, 1142, 1146, 1154, 1162, 1163, 1165, 1168, 1169, 1172, 1174, 1184, 1186, 1188, 1196, 1250, 1274, 1292, 1340, 1350, 1362, 1381, 1388, 1408, 1414, 1421, 1431, 1440, 1449, 1458, 1462, 1465, 1468, 1469, 1474, 1478, 1485, 1488, 1491, 1507, 1510, 1514, 1520, 1530, 1533, 1537, 1539, 1543, 1544, 1548, 1552, 1555, 1556, 1557, 1558, 1569, 1571, 1574, 1594, 1598, 1600, 1602, 1607, 1611, 1614, 1616, 1617, 1620, 1623, 1626, 1627, 1631, 1633, 1634, 1646, 1653, 1663, 1664, 1668, 1669, 1676, 1677, 1683, 1692, 1693, 1694, 1696, 1697, 1701, 1702, 1705, 1708, 1709, 1710, 1711, 1716, 1725, 1729, 1742, 1746, 1748, 1751, 1756, 1758, 1761, 1763, 1764, 1767, 1768, 1770, 1773, 1776, 1778, 1779, 1781, 1782, 1783, 1785, 1792, 1794, 1796, 1805, 1856, 1873, 1966, 1970, 1978, 2010, 2015, 2027, 2032, 2078, 2079, 2080, 2083, 2110, 2135, 2148, 2150, 2206, 2211, 2215, 2241, 2243, 2248, 2263, 2275, 2277, 2287, 2304, 2308, 2318, 2324, 2343, 2352, 2357, 2361, 2367, 2370, 2371, 2381, 2390, 2392, 2396, 2397, 2400, 2403, 2422, 2423, 2425, 2430, 2431, 2432, 2448, 2449, 2451, 2458, 2460, 2461, 2464, 2465, 2470, 2471, 2487, 2488, 2489, 2493, 2500, 2504, 2516, 2525, 2526, 2527, 2534, 2537, 2561, 2562, 2569, 2573, 2584, 2586, 2596, 2601, 2608, 2612, 2617, 2618, 2619, 2620, 2621, 2624, 2626, 2632, 2634, 2636, 2640, 2642, 2644, 2645, 2649, 2650, 2651, 2654, 2658, 2661, 2662, 2664, 2673, 2674, 2675, 2676, 2678, 2683, 2684, 2686, 2688, 2689, 2693, 2697, 2699, 2701, 2703, 2704, 2705, 2707, 2715, 2717, 2719, 2721, 2722, 2723, 2725, 2727, 2728, 2729, 2734, 2735, 2739, 2740, 2741, 2744, 2745, 2748, 2750, 2751, 2753, 2764, 2774, 2777, 2779, 2788, 2789, 2790, 2798, 2825, 2830, 2835, 2839, 2842, 2870, 2884, 2887, 2895, 2902, 2915, 2944, 2949, 2966, 2969, 2970, 2985, 2994, 2996, 2997, 2998, 3037, 3039, 3074, 3079, 3083, 3103, 3106, 3107, 3188, 3192, 3193, 3195, 3197, 3200, 3206, 3210, 3217, 3218, 3221, 3225, 3230, 3234, 3239, 3244, 3246, 3247, 3254, 3256, 3262, 3265, 3267, 3271, 3274, 3293, 3297, 3312, 3315, 3324, 3325, 3327, 3332, 3338, 3340, 3348, 3351, 3356, 3364, 3365, 3372, 3376, 3379, 3380, 3387, 3392, 3393, 3397, 3418, 3436, 3458, 3464, 3469, 3477, 3487, 3515, 3569, 3572, 3584, 3585, 3595, 3601, 3608, 3613, 3615, 3620, 3622, 3626, 3627, 3629, 3633, 3638, 3641, 3642, 3643, 3644, 3647, 3650, 3652, 3671, 3680, 3683, 3685, 3693, 3698, 3703, 3704, 3706, 3711, 3718, 3721, 3724, 3725, 3731, 3732, 3737, 3740, 3743, 3745, 3750, 3752, 3755, 3757, 3758, 3764, 3766, 3767, 3770, 3777, 3790, 3791, 3796, 3800, 3806, 3813, 3822, 3823, 3833, 3854, 3858, 3861, 3862, 3876, 3877, 3881, 3896, 3904, 3906, 3911, 3927, 3931, 3934, 3937, 3948, 3970, 3985, 3991, 4010, 4092, 4112, 4168, 4182, 4221, 4240, 4245, 4263, 4273, 4275, 4278, 4280, 4288, 4291, 4298, 4308, 4317, 4332, 4335, 4352, 4354, 4357, 4361, 4362, 4364, 4376, 4384, 4407, 4408, 4417, 4422, 4426, 4435, 4442, 4443, 4450, 4457, 4462, 4463, 4472, 4473, 4476, 4477, 4478, 4482, 4485, 4489, 4493, 4494, 4496, 4498, 4503, 4511, 4512, 4518, 4521, 4524, 4528, 4529, 4532, 4535, 4543, 4547, 4548, 4549, 4550, 4552, 4553, 4558, 4560, 4564, 4566, 4570, 4574, 4579, 4588, 4590, 4594, 4637, 4640, 4649, 4652, 4663, 4701, 4705, 4708, 4712, 4730, 4731, 4767, 4786, 4796, 4802, 4805, 4808, 4818, 4820, 4824, 4825, 4827, 4831, 4834, 4838, 4840, 4847, 4851, 4856, 4859, 4867, 4868, 4869, 4874, 4877, 4878, 4880, 4882, 4885, 4888, 4891, 4893, 4899, 4900, 4901, 4906, 4912, 4914, 4917, 4920, 4929, 4930, 4933, 4936, 4940, 4941, 4942, 4943, 4951, 4958, 4964, 4966, 4970, 4971, 4977, 4988, 4991, 4992, 4993, 5013, 5027, 5038, 5048, 5101, 5109, 5140, 5148, 5163, 5188, 5191, 5202, 5219, 5231, 5237, 5245, 5249, 5251, 5256, 5271, 5281, 5283, 5288, 5290, 5292, 5296, 5297, 5299, 5305, 5312, 5320, 5323, 5325, 5327, 5336, 5338, 5347, 5348, 5351, 5358, 5366, 5370, 5380, 5392, 5401, 5406, 5410, 5413, 5419, 5420, 5421, 5431, 5432, 5438, 5441, 5448, 5455, 5460, 5465, 5471, 5473, 5474, 5477, 5480, 5481, 5497, 5506, 5507, 5509, 5510, 5511, 5514, 5518, 5519, 5525, 5527, 5528, 5537, 5540, 5543, 5544, 5546, 5551, 5552, 5555, 5556, 5562, 5564, 5569, 5570, 5571, 5573, 5577, 5578, 5579, 5581, 5618, 5631, 5659, 5662, 5670, 5671, 5674, 5684, 5686, 5702, 5704, 5707, 5727, 5735, 5738, 5742, 5753, 5769, 5771, 5778, 5787, 5790, 5802, 5813, 5833, 5846, 5872, 5880, 5883, 5897, 5905, 5911, 5913, 5928, 5936, 5975, 5978, 5982, 5988, 6026, 6033, 6049, 6053, 6057, 6066, 6077, 6089, 6095, 6102, 6104, 6125, 6143, 6150, 6155, 6163, 6174, 6175, 6181, 6188, 6195, 6223, 6224, 6225, 6239, 6248, 6268, 6273, 6277, 6279, 6280, 6283, 6302, 6304, 6305, 6306, 6307, 6310, 6327, 6331, 6337, 6339, 6357, 6358, 6362, 6373, 6376, 6384, 6388, 6393, 6397, 6398, 6401, 6415, 6416, 6417, 6423, 6437, 6445, 6462, 6466, 6467, 6485, 6493, 6512, 6523, 6533, 6545, 6553, 6557, 6570, 6594, 6595, 6598, 6602, 6603, 6605, 6613, 6618, 6626, 6638, 6641, 6653, 6654, 6664, 6669, 6676, 6717, 6726, 6737, 6744, 6776, 6780, 6810, 6822, 6831, 6832, 6835, 6841, 6863, 6870, 6871, 6876, 6881, 6885, 6897, 6901, 6903, 6905, 6913, 6915, 6917, 6921, 6929, 6933, 6934, 6944, 6950, 6953, 6956, 6957, 6959, 6962, 6980, 6981, 6985, 6987, 6993, 6995, 6999, 7005, 7027, 7038, 7057, 7062, 7070, 7073, 7083, 7089, 7098, 7100, 7107, 7123, 7127, 7129, 7138, 7158, 7159, 7162, 7165, 7167, 7176, 7181, 7187, 7190, 7191, 7199, 7209, 7211, 7217, 7218, 7226, 7229, 7232, 7236, 7237, 7238, 7247, 7250, 7252, 7253, 7263, 7275, 7285, 7286, 7301, 7309, 7317, 7337, 7344, 7353, 7365, 7372, 7376, 7381, 7389, 7394, 7399, 7405, 7411, 7436, 7460, 7477, 7490, 7518, 7522, 7526, 7534, 7535, 7576, 7593, 7594, 7600, 7604, 7605, 7606, 7607, 7619, 7621, 7623, 7628, 7629, 7639, 7648, 7655, 7656, 7659, 7672, 7673, 7682, 7683, 7716, 7717, 7738, 7769, 7776, 7783, 7786, 7788, 7793, 7794, 7795, 7799, 7802, 7817, 7822, 7826, 7828, 7833, 7837, 7839, 7850, 7860, 7882, 7889, 7893, 7901, 7904, 7922, 7923, 7928, 7931, 7942, 7944, 7953, 7956, 7960, 7970, 7994, 8003, 8008, 8016, 8018, 8024, 8028, 8032, 8044, 8057, 8058, 8059, 8062, 8067, 8071, 8072, 8074, 8077, 8079, 8080, 8081, 8082, 8084, 8090, 8091, 8095, 8098, 8101, 8111, 8116, 8119, 8124, 8129, 8131, 8132, 8139, 8140, 8144, 8146, 8149, 8153, 8154, 8156, 8159, 8160, 8161, 8163, 8165, 8167, 8168, 8170, 8181, 8183, 8185, 8191, 8192, 8194, 8196, 8199, 8203, 8204, 8205, 8206, 8207, 8208, 8212, 8213, 8214, 8216, 8217, 8225, 8231, 8236, 8259, 8262, 8266, 8269, 8273, 8275, 8280, 8284, 8287, 8295, 8300, 8302, 8313, 8314, 8316, 8322, 8324, 8326, 8328, 8332, 8335, 8336, 8340, 8343, 8346, 8352, 8359, 8367, 8368, 8370, 8374, 8395, 8397, 8399, 8424, 8438, 8439, 8454, 8458, 8474, 8486, 8498, 8510, 8530, 8532, 8533, 8537, 8542, 8544, 8552, 8567, 8569, 8571, 8595, 8600, 8605, 8608, 8613, 8614, 8617, 8618, 8619, 8621, 8624, 8625, 8634, 8635, 8637, 8638, 8643, 8658, 8661, 8664, 8671, 8677, 8681, 8686, 8693, 8694, 8703, 8704, 8710, 8714, 8719, 8721, 8722, 8723, 8730, 8738, 8740, 8741, 8743, 8746, 8748, 8754, 8755, 8758, 8759, 8760, 8765, 8767, 8770, 8771, 8773, 8777, 8780, 8790, 8791, 8796, 8797, 8798, 8823, 8828, 8829, 8831, 8845, 8850, 8866, 8937, 9003, 9005, 9006, 9008, 9010, 9018, 9041, 9048, 9052, 9067, 9093, 9095, 9100, 9123, 9132, 9135, 9138, 9141, 9157, 9158, 9159, 9169, 9184, 9192, 9203, 9206, 9208, 9209, 9211, 9234, 9240, 9242, 9254, 9258, 9268, 9270, 9274, 9282, 9283, 9286, 9293, 9296, 9297, 9300, 9305, 9323, 9324, 9328, 9339, 9344, 9359, 9363, 9369, 9371, 9373, 9376, 9383, 9384, 9386, 9392, 9395, 9396, 9400, 9410, 9411, 9412, 9414, 9417, 9428, 9461, 9462, 9489, 9512, 9513, 9519, 9522, 9524, 9554, 9597, 9628, 9630, 9640, 9641, 9672, 9687, 9695, 9697, 9704, 9732, 9735, 9741, 9755, 9784, 9787, 9788, 9806, 9809, 9840, 9845, 9850, 9858, 9864, 9867, 9870, 9871, 9875, 9883, 9886, 9887, 9891, 9893, 9908, 9910, 9912, 9913, 9926, 9928, 9942, 9944, 9950, 9951, 9956, 9963, 9969, 9978, 9984, 9987, 9991, 9993, 9995, 9999};
    // std::vector<int> nl32 = {2, 8, 28, 32, 33, 42, 52, 56, 68, 78, 88, 89, 102, 111, 114, 115, 132, 139, 150, 154, 155, 158, 159, 166, 174, 184, 193, 202, 207, 253, 307, 311, 324, 359, 387, 393, 396, 426, 509, 552, 583, 641, 803, 812, 827, 832, 837, 842, 848, 861, 881, 896, 898, 899, 902, 913, 914, 930, 947, 959, 962, 972, 991, 995, 1021, 1040, 1044, 1066, 1068, 1073, 1111, 1142, 1188, 1362, 1403, 1408, 1444, 1458, 1470, 1485, 1491, 1548, 1568, 1571, 1574, 1655, 1798, 2403, 2410, 2422, 2430, 2448, 2461, 2462, 2471, 2487, 2489, 2494, 2497, 2498, 2517, 2525, 2539, 2544, 2547, 2548, 2561, 2569, 2573, 2574, 2584, 2586, 2601, 2609, 2611, 2616, 2618, 2619, 2624, 2630, 2632, 2634, 2639, 2640, 2642, 2651, 2654, 2658, 2661, 2662, 2664, 2673, 2674, 2676, 2678, 2681, 2683, 2684, 2689, 2697, 2699, 2701, 2704, 2705, 2706, 2707, 2710, 2711, 2728, 2729, 2733, 2734, 2739, 2740, 2744, 2745, 2751, 2754, 2756, 2758, 2759, 2772, 2776, 2779, 2784, 2787, 2789, 2790, 2795, 2798, 2810, 2835, 2994, 3458, 3487, 3569, 3800, 3822, 3852, 3854, 3862, 4191, 4417, 4435, 4443, 4447, 4451, 4456, 4464, 4466, 4473, 4484, 4485, 4543, 4549, 4552, 4560, 4564, 4566, 4570, 4571, 4579, 4590, 4594, 4836, 4945, 5350, 5355, 5438, 5510, 5630, 5686, 5717, 5742, 5778, 5790, 6004, 6017, 6066, 6089, 6095, 6298, 6314, 6433, 6833, 7027, 7032, 7054, 7070, 7083, 7089, 7098, 7107, 7113, 7129, 7162, 7165, 7190, 7204, 7208, 7215, 7217, 7224, 7236, 7237, 7247, 7250, 7253, 7258, 7263, 7269, 7275, 7285, 7286, 7300, 7301, 7315, 7327, 7376, 7411, 7414, 7477, 7607, 8016, 8023, 8044, 8080, 8101, 8149, 8201, 8215, 8501, 8510, 8567, 8579, 8605, 8617, 8625, 8648, 8664, 8736, 8744, 8755, 8757, 8780, 8797, 8828, 8829, 8831, 8924, 9062, 9138, 9212, 9234, 9240, 9265, 9280, 9282, 9301, 9311, 9388, 9697, 9736};
    // unsigned int* hit_record;
    unsigned long long* hit_record;
public:
    juno_core(std::string _dataset_dir, 
              DATASET ds=CUSTOM, 
              int _coarse_grained_cluster_num=1000, 
              T _radius=0.3,
              bool _use_pq=true, 
              RT_MODE _rt_mode=QUERY_AS_RAY
             ) 
    {
        // omp_set_num_threads(64);
        M = 2;
        CUDA_CHECK(cudaStreamCreate(&stream));
        dataset_dir = _dataset_dir;
        radius = _radius;
        switch (ds) {
            case SIFT1M:
                N = 1000000;
                D = 128;
                Q = 10000;
                PQ_entry = 32;
                metric = METRIC_L2;
                break;
            case SIFT1B:
                N = 100000000;
                D = 128;
                Q = 10;
                PQ_entry = 512;
                metric = METRIC_L2;
                break;
            case TTI1M:

                break;
            case TTI1B:

                break;
            case DEEP1M:
                N = 1000000;
                D = 96;
                Q = 10000;
                PQ_entry = 32;
                metric = METRIC_L2;
                break;
            case CUSTOM:
                N = 16;
                D = 4;
                Q = 1;
                PQ_entry = 4;
                metric = METRIC_L2;
                break;
            default:

                break;
        }
        use_pq = _use_pq;
        coarse_grained_cluster_num = _coarse_grained_cluster_num;
        rt_mode = _rt_mode;
        hit_record = new unsigned long long[QUERY_BATCH_MAX * NLISTS_MAX * (D / M) * (MAX_ENTRY / 32)];
        CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&hit_res), sizeof(uint8_t) * Q * N));
        sub_cluster_size = new int[coarse_grained_cluster_num * (D / M) * PQ_entry];
        // printf("Reading Search Points...");
        // search_points = new T* [N];
        // search_points_flatten = new T[N * D];
        // for (int i = 0; i < N; i++) search_points[i] = new T[D];
        // read_search_points<T>((dataset_dir + "search_points").c_str(), search_points, N, D);
        // for (int n = 0; n < N; n++) {
        //     for (int d = 0; d < D; d++) {
        //         search_points_flatten[n * D + d] = search_points[n][d];
        //     }
        // }
        // printf("Finished\n");
        search_points = NULL;
        printf("Reading Cluster Centroids...");
        cluster_centroids_vec.clear();
        cluster_centroids = new T* [coarse_grained_cluster_num];
        cluster_centroids_flatten = new T[coarse_grained_cluster_num * D];
        for (int i = 0; i < coarse_grained_cluster_num; i++) cluster_centroids[i] = new T[D];
        read_cluster_centroids<T>((dataset_dir + "parameter_0/" + "cluster_centroids_" + std::to_string(coarse_grained_cluster_num)).c_str(), cluster_centroids, coarse_grained_cluster_num, D);
        square_C = new T[coarse_grained_cluster_num];
        std::vector <T> centroid;
        for (int i = 0; i < coarse_grained_cluster_num; i++) {
            T res = 0.0;
            centroid.clear();
            for (int j = 0; j < D; j++) {
                res += cluster_centroids[i][j] * cluster_centroids[i][j];
                cluster_centroids_flatten[i * D + j] = cluster_centroids[i][j];
                centroid.push_back(cluster_centroids[i][j]);
            }
            cluster_centroids_vec.push_back(std::pair<int, std::vector<T>>(i, centroid));
            square_C[i] = res;
        }
        printf("Finished\n");
        printf("Reading Search Point Labels...");
        search_points_labels = new int[N];
        std::vector<std::vector<int>> cluster_points_mapping;
        read_search_points_labels((dataset_dir + "parameter_0/" + "search_points_labels_" + std::to_string(coarse_grained_cluster_num)).c_str(), search_points_labels, N);
        for (int n = 0; n < N; n++) {
            int label = search_points_labels[n];
            points_cluster_mapping[label].push_back(n);
        }
        cluster_size = new int[coarse_grained_cluster_num];
        for (int c = 0; c < coarse_grained_cluster_num; c++) {
            std::vector <int> place_holder;
            place_holder.clear();
            cluster_points_mapping.push_back(place_holder);
            int cnt = 0;
            for (int s = 0; s < N; s++) {
                if (search_points_labels[s] == c) {
                    cnt++;
                    cluster_points_mapping[c].push_back(s);
                }
            }
            cluster_size[c] = cnt;
        }
        printf("Finished\n");

        printf("Reading Ground Truth...");
        ground_truth = new int*[Q];
        ground_truth_flatten = new int[Q * 100];
        for (int i = 0; i < Q; i++) ground_truth[i] = new int[100];
        read_ground_truth((dataset_dir + "ground_truth").c_str(), ground_truth, Q);
        for (int q = 0; q < Q; q++) {
            for (int gt = 0; gt < 100; gt++) {
                ground_truth_flatten[q * 100 + gt] = ground_truth[q][gt];
            }
        }
        printf("Finished\n");

        // stat = new T*[D];
        // for (int i = 0; i < D; i++) {
        //     stat[i] = new T[4];    // Min, Max, Mean, Std
        //     std::vector <T> tmp;
        //     tmp.clear();
        //     for (int j = 0; j < N; j++) {
        //         tmp.push_back(search_points[j][i]);
        //     }
        //     stat[i][0] = *std::min_element(tmp.begin(), tmp.end());
        //     stat[i][1] = *std::max_element(tmp.begin(), tmp.end());
        //     stat[i][2] = std::accumulate(tmp.begin(), tmp.end(), 0.0) / (1.0 * N);
        //     stat[i][3] = std::sqrt(std::inner_product(tmp.begin(), tmp.end(), tmp.begin(), 0.0) / (1.0 * N) - stat[i][2] * stat[i][2]);
        // }
        if (use_pq == true) {
            
            printf("Reading Codebook Entry...");
            codebook_entry = new T***[coarse_grained_cluster_num];
            for (int c = 0; c < coarse_grained_cluster_num; c++) {
                codebook_entry[c] = new T**[D / M];
                for (int d = 0; d < D / M; d++) {
                    codebook_entry[c][d] = new T*[PQ_entry];
                    for (int e = 0; e < PQ_entry; e++) {
                        codebook_entry[c][d][e] = new T[PQ_DIM];
                    }
                }
            }

            codebook_labels = new int**[coarse_grained_cluster_num];
            for (int c = 0; c < coarse_grained_cluster_num; c++) {
                codebook_labels[c] = new int*[D / M];
                for (int d = 0; d < D / M; d++) {
                    codebook_labels[c][d] = new int[cluster_size[c]];
                }
            }
            read_codebook_entry_labels(dataset_dir + "parameter_0/" + "codebook_" + std::to_string(coarse_grained_cluster_num), codebook_entry, codebook_labels, cluster_size, coarse_grained_cluster_num, PQ_entry, D);
            printf("Finished\n");
            
            inversed_codebook_map = new std::vector<int>** [coarse_grained_cluster_num];
            // inversed_codebook_map_localid = new std::vector<int>** [coarse_grained_cluster_num];
            int tmp_cnt = 0;
            // omp_set_num_threads(48);
            // #pragma omp parallel for
            for (int _c = 0; _c < coarse_grained_cluster_num; _c++) {
                int c = _c;
            // for (int c = 0; c < coarse_grained_cluster_num; c++) {
                inversed_codebook_map[c] = new std::vector<int>* [D / M];
                // inversed_codebook_map_localid[c] = new std::vector<int>* [D / M];
                for (int d = 0; d < D / M; d++) {
                    inversed_codebook_map[c][d] = new std::vector<int> [PQ_entry];
                    // inversed_codebook_map_localid[c][d] = new std::vector<int> [PQ_entry];
                    for (int e = 0; e < PQ_entry; e++) {
                        inversed_codebook_map[c][d][e].clear();
                        // inversed_codebook_map_localid[c][d][e].clear();
                        for (int n = 0; n < cluster_size[c]; n++) {
                            if (codebook_labels[c][d][n] == e) {
                                inversed_codebook_map[c][d][e].push_back(cluster_points_mapping[c][n]);
                                // inversed_codebook_map_localid[c][d][e].push_back(n);
                            }
                        }
                        // sub_cluster_size[c * (D / M) * PQ_entry + d * PQ_entry + e] = inversed_codebook_map[c][d][e].size();
                    }
                }
                // #pragma omp critical 
                // {
                    tmp_cnt ++;
                    printf("%d\n", tmp_cnt);
                // }
            }
            
        }
        dbg("Finish Reading Dataset and Cluster Info.");
    }

    void setupBVHDict() {
        OPTIX_CHECK(optixInit());
        for (int c = 0; c < coarse_grained_cluster_num; c++) {
            bvh_dict[c] = new juno_rt<T>(Q, D);
            bvh_dict[c]->constructBVHforLabelWithRadius(c, search_points, search_points_labels, N, D, stat, radius, metric);
            
        }
    }

    void buildJunoIndex() {
        OPTIX_CHECK(optixInit());
        for (int c = 0; c < coarse_grained_cluster_num; c++) {
            bvh_dict[c] = new juno_rt<T>();
            bvh_dict[c]->constructBVHwithPQ(c, codebook_entry, PQ_entry, D, M, stat, radius, metric);
            std::remove("/var/tmp/OptixCache_zhliu/optix7cache.db");
        }
    }

    void buildJunoIndexWhole(float al, float be) {
        OPTIX_CHECK(optixInit());
        std::remove("/var/tmp/OptixCache_zhliu/optix7cache.db");
        bvh_dict[0] = new juno_rt<T>(Q);
        bvh_dict[0]->constructCompleteBVHwithPQ(codebook_entry, coarse_grained_cluster_num, PQ_entry, D, M, stat, radius, metric, al, be);
    }

    void serveQueryWhole(juno_query_batch<T>* _query_batch, int nlists) {
        // omp_set_num_threads(16);
        assert((nlists < NLISTS_MAX) || "Max nlists exceeded.\n");
        // 1st filtering, can be optimized using CUDA/OpenMP
        struct timeval st, ed;
        T** query_data = _query_batch->getQueryData();
        T* query_data_flatten = _query_batch->getFlattenQueryData();
        int query_size = _query_batch->getQuerySize();
        int cluster_bias[coarse_grained_cluster_num] = {-1};
        int cluster_query_size[coarse_grained_cluster_num] = {0};
        // Record which queries fall into the cluster C
        std::vector<std::vector<int>> cluster_query_mapping;
        int *total_candidate = new int[query_size];
        
        // Record which clusters a query falls in
        std::vector<std::vector<std::pair<int, int>>> query_cluster_mapping;
        float **L2mat = new float*[query_size];
        for (int q = 0; q < query_size; q++) L2mat[q] = new float[coarse_grained_cluster_num];
        // Can be optimized with OpenBLAS   
        gettimeofday(&st, NULL);     
        for (int q = 0; q < query_size; q++) {
            // Calculate the L2-dist between every cluster centroids
            // #pragma omp parallel for
            for (int c = 0; c < coarse_grained_cluster_num; c++) {
                L2mat[q][c] = L2Dist(query_data[q], cluster_centroids[c], D);
            }
            std::vector <std::pair<int, int>> query_place_holder;
            query_cluster_mapping.push_back(query_place_holder);
        }

        gettimeofday(&ed, NULL);
        elapsed("Calculate L2 Dist[CPU]", st, ed);
        // Init 


        gettimeofday(&st, NULL);
        for (int c = 0; c < coarse_grained_cluster_num; c++) {
            std::vector<int> query_ids;
            query_ids.clear();
            cluster_query_mapping.push_back(query_ids);
        }
        // Can be optimized use OpenMP/CUDA
        // #pragma omp parallel for
        std::map<int, int> used_cluster;
        for (int q = 0; q < query_size; q++) {
            int cnt = 0;
            std::vector <T> query_vec;
            query_vec.clear();
            for (int d = 0; d < D; d++) {
                query_vec.push_back(query_data[q][d]);
            }

            // Sort by L2 distance
            std::sort(cluster_centroids_vec.begin(), cluster_centroids_vec.end(), [q, L2mat](const std::pair<int, std::vector <T>>& a, const std::pair<int, std::vector <T>>& b) {
                return L2mat[q][a.first] < L2mat[q][b.first];
            });

            // Select nlists cluster
            for (int nl = 0; nl < nlists; nl++) {
                // Record a pair, stands for: <the cluster c this query q use, the position this query q falls in the cluster c>
                query_cluster_mapping[q].push_back(std::pair<int, int>(cluster_centroids_vec[nl].first, cluster_query_mapping[cluster_centroids_vec[nl].first].size()));
                // Push query q into the query_list of cluster c
                cluster_query_mapping[cluster_centroids_vec[nl].first].push_back(q);
                cnt += cluster_size[cluster_centroids_vec[nl].first];
                used_cluster[cluster_centroids_vec[nl].first] = 1;
            }
            total_candidate[q] = cnt;
        }
        gettimeofday(&ed, NULL);
        elapsed("Filtering[CPU]", st, ed);
        // for (auto&& item : used_cluster) {
        //     std::cout << item.first << ", ";
        // }
        // std::cout << std::endl;
        // 2nd setting ray origins
        gettimeofday(&st, NULL);
        float3* ray_origin_whole = new float3[Q * (D / M) * nlists];
        int index_bias = 0, accum = 0;
        // Ray Layout: 10000 * nlists * D / 2 rays
        // [............Cluster 1 Ray.............][............Cluster 2 Ray.............]........
        // |                                       \
        // [Dim 00 Ray][Dim 01 Ray]......[Dim 63 Ray]
        // |           \                 |           \
        // [q0,q1,...,qc]                [q0,q1,...,qc]
        for (int c = 0; c < coarse_grained_cluster_num; c++) {
            int query_of_cluster_c = cluster_query_mapping[c].size();
            cluster_bias[c] = accum;
            cluster_query_size[c] = cluster_query_mapping[c].size();
            accum += query_of_cluster_c;
            float bias = 1.0 * c;
            for (int d = 0; d < D / M; d++) {
                for (int q = 0; q < query_of_cluster_c; q++) {
                    float x = (1.0 * query_data[cluster_query_mapping[c][q]][2 * d]) / 100.0;
                    float y = (1.0 * query_data[cluster_query_mapping[c][q]][2 * d + 1]) / 100.0;
                    ray_origin_whole[index_bias] = make_float3(x, y, 1.0 * (c * 128 + 2 * d));
                    index_bias++;
                }
            }
        }
        gettimeofday(&ed, NULL);
        elapsed("Setting Ray Origin[CPU]", st, ed);
        // std::sort(ray_origin_whole, ray_origin_whole + index_bias, [](float3 a, float3 b){
        //     if (abs(a.z - b.z) > 1e-3) return a.z < b.z;
        //     else {
        //         if (abs(a.x - b.x) > 1e-3) return a.x < b.x;
        //         else {
        //             if (abs(a.y - b.y) > 1e-3) return a.y < b.y;
        //         }
        //     }
        // });
        gettimeofday(&st, NULL);
        bvh_dict[0]->setRayOrigin(ray_origin_whole, index_bias);
        gettimeofday(&ed, NULL);
        elapsed("Copying Ray Origin H->D[GPU]", st, ed);
        gettimeofday(&st, NULL);
        auto pipeline = bvh_dict[0]->getOptixPipeline();
        auto d_param = bvh_dict[0]->getDparams();
        auto sbt = bvh_dict[0]->getSBT();   
        OPTIX_CHECK(optixLaunch(pipeline, stream, d_param, sizeof(Params), sbt, index_bias, 1, 1));
        CUDA_SYNC_CHECK();
        gettimeofday(&ed, NULL);
        elapsed("Ray Tracing", st, ed);
        float us = 1000000.0 * (ed.tv_sec - st.tv_sec) + 1.0 * (ed.tv_usec - st.tv_usec);

        
        gettimeofday(&st, NULL);
        bvh_dict[0]->getRayHitRecord(hit_record, index_bias);
        int r1_100 = 0;
        int r100_1000 = 0;
        #pragma omp parallel for
        for (int q = 0; q < query_size; q++) {
            std::vector <std::pair<int, int>> sort_res;
            sort_res.clear();
            for (int nl = 0; nl < nlists; nl++) {
                int tmp_cluster = query_cluster_mapping[q][nl].first;
                int query_in_cluster_id = query_cluster_mapping[q][nl].second;
#if VERBOSE == 1
                printf("Query: %d, Cluster: %d, Bias: %d\n", q, tmp_cluster, query_in_cluster_id);
#endif
                int base_addr = cluster_bias[tmp_cluster] * (D / M) * (MAX_ENTRY / 32);
                int stride = cluster_query_mapping[tmp_cluster].size() * (MAX_ENTRY / 32);
                std::unordered_map <int, int> point_counter_mapping;
                unsigned long long one = 1, zero = 0;
                for (int bit_id = 0; bit_id < (MAX_ENTRY / 32); bit_id++) {
                    if (bit_id >= (CURRENT_ENTRY / 32)) break;
                    for (int d = 0; d < D / M; d++) {
                        unsigned long long hit_res = hit_record[base_addr + query_in_cluster_id * (MAX_ENTRY / 32) + bit_id + d * stride];
                        for (unsigned int bit = 0; bit < 32; bit++) {
                            int cnt = 0 ;
                            if ((hit_res & (one << (bit * 2))) != zero) cnt ++ ;
                            if ((hit_res & (one << (bit * 2 + 1))) != zero) cnt ++ ;
                            if (cnt != 0) {
                                for (auto && item : inversed_codebook_map[tmp_cluster][d][bit]) {
                                    point_counter_mapping[item] += cnt ;
                                }
                            }
                            // if ((hit_res & (one << (bit * 2))) != zero) {
                            //     // int cnt = 0;
                            //     for (auto && item : inversed_codebook_map[tmp_cluster][d][bit]) {
                            //         point_counter_mapping[item] ++;
                            //         // cnt ++;
                            //     }
                            // // std::cout << cnt << "/" << total_candidate[q] << std::endl;
                            // }
                            // if ((hit_res & (one << (bit * 2 + 1))) != zero) {
                            //     for (auto && item : inversed_codebook_map[tmp_cluster][d][bit]) {
                            //         point_counter_mapping[item] ++;
                            //     }
                            // }
                        }
#if VERBOSE == 1
                        if (bit_id == 0) printf("%08x%c", hit_res, (d % 16 == 15) ? ' ' : ' ');
#endif
                    }
#if VERBOSE == 1
                    if (bit_id == 0) printf("\n");
#endif
                    for (auto it = point_counter_mapping.begin(); it != point_counter_mapping.end(); it++) {
                        sort_res.push_back(std::pair<int, int>(it->first, it->second));
                    }
                }
            }
            sort(sort_res.begin(), sort_res.end(), [](const std::pair<int, int> a, const std::pair<int, int> b) {return a.second > b.second;});
            // std::cout << sort_res.size() << std::endl;
            // for (auto&& item : sort_res) {
            //     std::cout << item.first << " " << item.second << std::endl;
            // }
            int local_r1_100 = 0;
            for (int topk = 0; topk < 100; topk++) {
                // std::cout << "(" << sort_res[topk].first << ", " << sort_res[topk].second << "), " << std::endl;
                if (sort_res[topk].first == ground_truth[q][0]) {
                    local_r1_100++;
                    break;
                }
            }
            #pragma omp critical 
            {
                r1_100 += local_r1_100;
            }
            int local_r100_1000 = 0;
            for (int gt = 0; gt < 100; gt++) {
                for (int topk = 0; topk < 1000; topk++) {
                    if (sort_res[topk].first == ground_truth[q][gt]) {
                        local_r100_1000 ++;
                        break;
                    }
                }
            }
            #pragma omp critical 
            {
                r100_1000 += local_r100_1000;
            }
        }
        
        std::cout << r1_100 << " " << (1.0 * r100_1000) / (1.0 * query_size) << std::endl;
        gettimeofday(&ed, NULL);
        elapsed("Computing Hit Result", st, ed);
        std::ofstream fres("result", std::fstream::out | std::fstream::app);
        fres << (query_size * 1000.0) / (us / 1000.0) << ", " << (1.0 * r1_100) / (1.0 * query_size) << ", " << (1.0 * r100_1000) / (1.0 * query_size) << "\n";
        fres.close();
        bvh_dict[0]->freeResources();
    }

    void serveQuery(juno_query_batch<T>* _query_batch, int nlists) {
        // juno_rt<T>.initRayOriginArray(Q, D, M, nlists);
        struct timeval st, ed;
        gettimeofday(&st, NULL);
        T** query_data = _query_batch->getQueryData();
        T* query_data_flatten = _query_batch->getFlattenQueryData();
        int query_size = _query_batch->getQuerySize();
        std::vector<std::vector<int>> cluster_query_mapping;
        float **L2mat = new float*[query_size];
        // Can be optimized with OpenBLAS
        for (int q = 0; q < query_size; q++) {
            L2mat[q] = new float[coarse_grained_cluster_num];
            for (int c = 0; c < coarse_grained_cluster_num; c++) {
                L2mat[q][c] = L2Dist(query_data[q], cluster_centroids[c], D);
            }
        }
        std::cout << "L2 calc complete" << std::endl;
        for (int c = 0; c < coarse_grained_cluster_num; c++) {
            std::vector<int> query_ids;
            query_ids.clear();
            cluster_query_mapping.push_back(query_ids);
        }
        // Can be optimized use OpenMP/CUDA
        for (int q = 0; q < query_size; q++) {
            std::vector <T> query_vec;
            query_vec.clear();
            for (int d = 0; d < D; d++) {
                query_vec.push_back(query_data[q][d]);
            }
            std::sort(cluster_centroids_vec.begin(), cluster_centroids_vec.end(), [q, L2mat](const std::pair<int, std::vector <T>>& a, const std::pair<int, std::vector <T>>& b) {
                return L2mat[q][a.first] < L2mat[q][b.first];
            });
            for (int nl = 0; nl < nlists; nl++) {
                cluster_query_mapping[cluster_centroids_vec[nl].first].push_back(q);
            }
        }
        gettimeofday(&ed, NULL);
        elapsed("Filtering", st, ed);
        gettimeofday(&st, NULL);
        int res = 0;
        for (int c = 0; c < 1; c++) {
            int query_of_cluster_c = cluster_query_mapping[c].size();
            float3* ray_origin = new float3[query_of_cluster_c * D / M];
            for (int d = 0; d < D / M; d++) {
                for (int q = 0; q < query_of_cluster_c; q++) {
                    float x = 1.0 * query_data[cluster_query_mapping[c][q]][2 * d];
                    float y = 1.0 * query_data[cluster_query_mapping[c][q]][2 * d + 1];
                    ray_origin[d * query_of_cluster_c + q] = make_float3(x, y, 1.0 * 2 * d);
                } 
            }
            bvh_dict[c]->setRayOrigin(ray_origin, query_of_cluster_c * D / M);
            delete [] ray_origin;
            auto pipeline = bvh_dict[c]->getOptixPipeline();
            auto d_param = bvh_dict[c]->getDparams();
            auto sbt = bvh_dict[c]->getSBT();      
            // query_of_cluster_c * D / M
            OPTIX_CHECK(optixLaunch(pipeline, stream, d_param, sizeof(Params), sbt, query_of_cluster_c * D / M, 1, 1));
            CUDA_SYNC_CHECK();
        }
        gettimeofday(&ed, NULL);
        elapsed("Ray Tracing", st, ed);
        
    }

    // Legacy
    void serveQueryBatch(juno_query_batch<T>* _query_batch) {
        // square_Q[0 : Batch - 1], square_C[0 : cluster_num - 1]
        // square_Q[i] = sum([x^2 for x in     query[i]])   [ Online]
        // square_C[i] = sum([x^2 for x in centroids[i]])   [Offline]
        // QC = matmul(Queries (Batch * Dim), Centroids^T (Dim * cluster_num)) [ Online] [cuBLAS]
        // Dist[i][j] = sqrt(square_Q[i] + square_C[j] - 2 * QC[i][j])
        unsigned int* h_hit;
        struct timeval st, ed;
        gettimeofday(&st, NULL);
        T** tmp = _query_batch->getQueryData();
        T* tmp_flatten = _query_batch->getFlattenQueryData();
        int query_size = _query_batch->getQuerySize();
        square_Q = new T[query_size];
        T** QC;
        T* QC_flatten;
        QC = new T*[query_size];
        int *selected_centroids = new int[query_size];
        QC_flatten = new T[query_size * coarse_grained_cluster_num];
        for (int i = 0; i < query_size; i++) QC[i] = new T[coarse_grained_cluster_num];
        for (int q = 0; q < query_size; q++) {
            T res = 0.0;
            for (int d = 0; d < D; d++) {
                res += tmp[q][d] * tmp[q][d];
            }
            square_Q[q] = res;
        }
        
        // for (int i = 0; i < query_size; i++) {
        //     for (int j = 0; j < coarse_grained_cluster_num; j++) {
        //         QC[i][j] = 0.0f;
        //         for (int k = 0; k < D; k++) {
        //             QC[i][j] += tmp[i][k] * cluster_centroids[j][k];
        //         }
        //     }
        // }
#if COARSE_GRAIN_CLUSTER_USE_GPU == 1
        // Don't
        // Disaster
#else
        
        if (typeid(T) == typeid(float)) {
            // export OPENBLAS_NUM_THREADS=16, ~0.35ms
            // cblas_sgemm(CblasRowMajor, 
            //             CblasNoTrans, 
            //             CblasTrans,
            //             query_size,
            //             coarse_grained_cluster_num,
            //             D,
            //             1.0f,
            //             tmp_flatten, 
            //             D, 
            //             cluster_centroids_flatten,
            //             D, 
            //             0.0f,
            //             QC_flatten, 
            //             coarse_grained_cluster_num);
        }
        else if (typeid(T) == typeid(double)) {
            // cblas_dgemm(CblasRowMajor, 
            //             CblasNoTrans, 
            //             CblasTrans,
            //             query_size,
            //             coarse_grained_cluster_num,
            //             D,
            //             1.0f,
            //             tmp_flatten, 
            //             D, 
            //             cluster_centroids_flatten,
            //             D, 
            //             0.0f,
            //             QC_flatten, 
            //             coarse_grained_cluster_num);
        }
#endif
        for (int i = 0; i < query_size; i++) {
            int min = 1e10, id = -1;
            for (int j = 0; j < coarse_grained_cluster_num; j++) {
                QC[i][j] = sqrt(square_C[j] + square_Q[i] - 2 * QC_flatten[i * coarse_grained_cluster_num + j]);
                if (QC[i][j] < min) {
                    min = QC[i][j];
                    id = j;
                }
            }
            selected_centroids[i] = id;
        }
        gettimeofday(&ed, NULL);
        // elapsed("Coarse Grained Clustering", st, ed);

        float3* ray_origins = new float3[query_size * D / 2];
        for (int q = 0; q < query_size; q++) {
            for (int d = 0; d < D; d+=2) {
                float x = 1.0 * tmp[q][d], y = 1.0 * tmp[q][d + 1];
                ray_origins[q * (D >> 1) + (d >> 1)] = make_float3(x, y, 1.0 * (d >> 1) + 0.5);
            }
        }
        std::cout << selected_centroids[0] << std::endl;
        for (int i = 0; i < query_size; i++) {
            bvh_dict[selected_centroids[i]]->setRayOrigin(ray_origins + i * D / M, D / M);
        }
        std::cout << "Ray Set" << std::endl;
        gettimeofday(&st, NULL);
        for (int i = 0; i < 1; i++) {
            auto pipeline = bvh_dict[selected_centroids[i]]->getOptixPipeline();
            auto d_param = bvh_dict[selected_centroids[i]]->getDparams();
            auto sbt = bvh_dict[selected_centroids[i]]->getSBT();
            OPTIX_CHECK(optixLaunch(pipeline, stream, d_param, sizeof(Params), sbt, 64, 1, 1));
            
            CUDA_SYNC_CHECK();
            // @TODO: 1. can't get correct hit report with correct primitive number
            //        2. Though we can, the time will be 2ms for query=100, QPS is 50000, bad.
            // break;
            // CUDA_SYNC_CHECK();
            // auto device_hit = bvh_dict[selected_centroids[i]]->getPrimitiveHit();
            // int hn = bvh_dict[selected_centroids[i]]->getHitableNum();
            // CUDA_CHECK(cudaMallocHost(reinterpret_cast<void**>(&h_hit), sizeof(unsigned int) * hn));
            // CUDA_CHECK(cudaMemcpy(h_hit, reinterpret_cast<void*>(device_hit), sizeof(unsigned int) * hn, cudaMemcpyDeviceToHost));
            // std::vector <std::pair<int, int>> candidate;
            // for (int x = 0; x < hn / 64; x++) {
            //     for (int y = 0; y < 64; y++) {
            //         std::cout << h_hit[y * (hn / 64) + x] << std::endl;
            //     }
            // }
            // int g_cnt = 0;
            // for (int x = 0; x < 64; x++) {
            //     int cnt = 0;
            //     for (int y = 0; y < hn / 64; y++) {
            //         std::cout << h_hit[x * (hn / 64) + y] << std::endl;
            //     }
            //     candidate.push_back(std::pair<int, int>(points_cluster_mapping[19][x], cnt));
            // }
            // for (auto && c : candidate) {
            //     std::cout << c.first << " " << c.second << std::endl;
            // }
            // std::sort(candidate.begin(), candidate.end(), [](std::pair<int, int> a, std::pair<int, int> b) {return a.second > b.second;});
            // int recall = 0;
            // for (int top = 0; top < 100; top++) {
            //     for (int c = 0; c < 1000; c++) {
            //         if (candidate[c].first == ground_truth[0][top]) {
            //             recall++;
            //         }
            //     }
            // }

        }
        // dbg(query_size);
        gettimeofday(&ed, NULL);
        elapsed("Ray Tracing Intersection Test", st, ed);

    }

    void plotDataset(juno_query_total<T>* query_total) {
        // plotQueryWithDensity(search_points_flatten, query_total->getQueryDataFlatten(), cluster_centroids_flatten, search_points_labels, query_total->getaGroundTruthFlatten() , N, query_total->getQueryAmount(), D, coarse_grained_cluster_num);
        referenceModel(search_points_flatten, query_total->getQueryDataFlatten(), cluster_centroids_flatten, search_points_labels, query_total->getaGroundTruthFlatten() , N, query_total->getQueryAmount(), D, coarse_grained_cluster_num, stat);
    }
}; // class juno_core

}; // namespace juno

#endif
